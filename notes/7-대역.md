# 대역

## 대역의 필요성

테스트를 작성하다 보면 외부 요인이 필요한 경우가 있다.

- 테스트 대상에서 File System 을 사용
- 테스트 대상에서 DB 호출
- 테스트 대상에서 외부 HTTP 서버 통신

이렇게 테스트 대상이 외부 요인에 의존하면 테스트를 작성하고 실행하기가 어렵고 결과를 예측할 수 없게 된다. (일시 장애, 데이터 등)

다음과 같이 실제 외부 서비스를 호출하는 테스트가 있다.

```java
public class AutoDebitRegisterTest {
    private AutoDebitRegister register;

    @BeforeEach
    void setUp() {
        CardNumberValidator validator = new CardNumberValidator();
        AutoDebitInfoRepository repository = new JpaAutoDebitInfoRepository();
        register = new AutoDebitRegister(validator, repository);
    }

    @Test
    void validCard() {
        // 업체에서 받은 테스트용 유효한 카드번호 사용
        AutoDebitReq req = new AutoDebitReq("user1", "1234123412341234");
        RegisterResult result = this.register.register(req);
        assertEquals(CardValidity.VALID, result.getValidity());
    }

    @Test
    void stolenCard() {
        // 업체에서 받은 테스트용 도난 카드번호 사용
        AutoDebitReq req = new AutoDebitReq("user1", "1002200230034004");
        RegisterResult result = this.register.register(req);
        assertEquals(CardValidity.STOLEN, result.getValidity());
    }
}
```

`CardNumberValidator` 클래스에는 외부 서비스와의 HTTP 통신을 하는 `validate` 메서드가 있고, `AutoDebitRegister` 의 `register` 메서드는 `validate` 를 호출한다.

만약 업체에서 제공한 카드의 유효기간이 한달밖에 남지 않았다면, 지금은 통과하는 테스트가 한달 뒤부터는 실패하게 되는 문제가 발생한다.

업체에서 제공한 도난 카드를 해당 업체에서 삭제할 경우에도 테스트는 실패한다.

이럴 때 대역을 써서 테스트를 진행할 수 있다.

고난이도 액션이 필요할 때 배우를 대신해서 연기하는 스턴트맨처럼 테스트에서는 외부 요인을 대신하는 대역이 외부 요인을 대신해서 테스트에 참여한다.

## 대역을 이용한 테스트

외부 서비스를 호출하는 `CardNumberValidator` 를 대신할 대역 클래스를 작성해보자.

```java
public class StubCardNumberValidator extends CardNumberValidator {
    private String stolenCardNumber;

    public void setStolenCardNumber(String stolenCardNumber) {
        this.stolenCardNumber = stolenCardNumber;
    }

    @Override
    public CardValidity validate(String cardNumber) {
        if (stolenCardNumber != null && stolenCardNumber.equals(cardNumber)) {
            return CardValidity.STOLEN;
        }
        return CardValidity.VALID;
    }
}
```

`StubCardNumberValidator` 는 실제 카드번호 검증 기능을 구현하지 않고 단순한 구현으로 실제 구현을 대체한다.

이를 적용하여 위 테스트 코드를 수정하면,

```java
public class AutoDebitRegisterStubTest {
    private AutoDebitRegister register;
    private StubCardNumberValidator stubValidator;

    @BeforeEach
    void setUp() {
        stubValidator = new StubCardNumberValidator();
        AutoDebitInfoRepository repository = new JpaAutoDebitInfoRepository();
        register = new AutoDebitRegister(stubValidator, repository);
    }

    @Test
    void stolenCard() {
        stubValidator.setStolenCardNumber("1111222233334444");

        AutoDebitReq req = new AutoDebitReq("user1", "1111222233334444");
        RegisterResult result = this.register.register(req);

        assertEquals(CardValidity.STOLEN, result.getValidity());
    }
}
```

`setUp` 메서드와 같이 `AutoDebitRegister` 는 실제 객체 대신에 `stubValidator` 를 사용하게 된다.

이렇게 되면 쉽게 `INVALID` 카드번호에 대한 테스트도 추가가 가능하다.

DB 연동 코드도 대역을 이용해서 `StubAutoDebitInfoRepository` 로 대체했다.

```java
public class MemoryAutoDebitInfoRepository implements AutoDebitInfoRepository {
    private Map<String, AutoDebitInfo> info = new HashMap<>();

    @Override
    public void save(AutoDebitInfo autoDebitInfo) {
        info.put(autoDebitInfo.getUserId, autoDebitInfo);
    }

    @Override
    public AutoDebitInfo findOne(String userId) {
        return info.get(userId);
    }
}
```

이렇게 DB 대신 Map 을 이용하여 메모리를 활용하면 DB와 같이 영속성을 제공하지는 않지만 충분히 테스트에 사용할 수 있을 만큼의 기능은 제공한다.

위 테스트 코드에 이를 적용하면 아래와 같은 테스트를 진행할 수 있게 된다.

```java
public class AutoDebitRegisterStubTest {
    private AutoDebitRegister register;
    private StubCardNumberValidator cardNumberValidator;
    private MemoryAutoDebitInfoRepository repository;

    @BeforeEach
    void setUp() {
        cardNumberValidator = new StubCardNumberValidator();
        repository = new MemoryAutoDebitInfoRepository();
        register = new AutoDebitRegister(cardNumberValidator, repository);
    }

    @Test
    void updateExistingUserInfo() {
        repository.save(new AutoDebitInfo("user1", "1111222233334444", LocalDateTime.now()));

        AutoDebitReq req = new AutoDebitReq("user1", "1234123412341234");
        RegisterResult result = this.register.register(req);

        AutoDebitInfo saved = repository.findOne("user1");
        assertEquals("1234123412341234", saved.getCardNumber());
    }

    @Test
    void registerNewUserInfo() {
        AutoDebitReq req = new AutoDebitReq("user1", "1357246813572468");
        RegisterResult result = this.register.register(req);

        AutoDebitInfo saved = repository.findOne("user1");
        assertEquals("1357246813572468", saved.getCardNumber());
    }
}
```

## 대역의 종류

- **Stub**: 구현을 단순한 것으로 대체한다. 테스트에 맞게 단순히 원하는 동작을 수행한다. 위의 `StubCardNumberValidator`가 stub 대역에 해당한다.
- **Fake**: 제품에는 적합하지 않지만, 실제 동작하는 구현을 제공한다. DB 대신에 메모리를 이용해서 구현한 `MemoryAutoDebitInfoRepository`가 fake 대역에 해당한다.
- **Spy**: 호출된 내역을 기록한다. 기록한 내용은 테스트 결과를 검증할 때 사용한다. **stub**이기도 하다.
- **Mock**: 기대한 대로 상호작용하는지 행위를 검증한다. 기대한 대로 동작하지 않으면 exception이 발생할 수 있다. **mock**객체는 **stub**이자 **spy**도 된다.  

회원 가입 기능을 예로 들어 대역을 살펴보자.

- `UserRegister`: 회원 가입에 대한 핵심 로직을 수행한다.
- `WeakPasswordChecker`: 암호가 약한지 검사한다.
- `UserRepository`: 회원 정보를 저장하고 조회하는 기능을 제공한다.
- `EmailNotifier`: 이메일 발송 기능을 제공한다.

`UserRegister` 에 대한 테스트를 만들어 나가는 과정에서 나머지 타입을 위한 대역으로 stub, fake, spy, mock 객체를 사용해보자.

### 약한 함호 확인 기능에 Stub 사용

암호가 약한 경우 회원 가입에 실패해야 한다.

테스트 대상이 `UserRegister` 이므로 `WeakPasswordChecker` 에 대역을 적용한다.

실제 동작하는 구현은 필요하지 않으므로 약한 암호인지 여부만 알려주는 `Stub` 대역이면 충분하다.

```java
public class StubWeakPasswordChecker implements WeakPasswordChecker {
    private boolean weak;

    public void setWeak(boolean weak) {
        this.weak = weak;
    }
}
```

위 `StubWeakPasswordChecker` 를 활용하는 테스트 코드를 아래와 같이 작성한다.

```java
@Test
void 약한_암호면_가입_실패() {
    stubWeakPasswordChecker.setWeak(true); // 암호가 약하다고 응답하도록 설정

    assertThrows(WeakPasswordException.class, () -> {
        userRegister.register("id", "pw", "email");
    });
}
```

위 테스트를 통과시키는 가장 쉬운 방법은 `UserRegister.register()` 메서드가 아래와 같이 익셉션을 바로 던지게끔 구현하는 것이다.

```java
public class UserRegister {
    ...
    public void register(String id, String pw, String email) {
        throw new WeakPasswordException();
    }
}
```

그 뒤 해당 부분을 일반화해보면, 아래와 같이 수정할 수 있다.

```java
public class UserRegister {
    ...
    public void register(String id, String pw, String email) {
        if (passwordChecker.checkPasswordWeak(pw)) {
            throw new WeakPasswordException();
        }
    }
}
```

그런 뒤 `checkPasswordWeak` 메서드를 추가하면 된다.

```java
public class StubWeakPasswordChecker implements WeakPasswordChecker {
    private boolean weak;

    public void setWeak(boolean weak) {
        this.weak = weak;
    }

    @Override
    public boolean checkPasswordWeak(String pw) {
        return weak;
    }
}
```

`StubWeakPasswordChecker` 의 `checkPasswordWeak` 메서드는 단순히 `weak` 필드 값을 리턴하는데, 이 정도만 해도 `UserRegister` 가 약한 암호인 경우와 그렇지 않은 경우에 대해 올바르게 동작하는지 확인할 수 있다.

### Repository 를 Fake 구현으로 사용

회원가입 시 동일한 ID를 가진 회원이 존재할 경우 익셉션을 던지는 테스트를 작성하자.

가장 쉬운 방법은 Repository 에 회원을 추가해놓는 것이다.

위에서 `MemoryAutoDebitInfoRepository` 를 사용했던 것과 동일하게 `UserRepository` 도 동일하게 동작하는 `Fake` 대역을 이용해서 이미 같은 ID를 가진 사용자가 존재하는 상황을 만들면 된다.

우선 테스트부터 작성해보자면,

```java
public class UserRegisterTest {
    private UserRegister userRegister;
    private StubWeakPasswordChecker stubWeakPasswordChecker = new StubWeakPasswordChecker();
    private MemoryUserRepository fakeRepository = new MemoryUserRepository();

    @BeforeEach
    void setUp() {
        userRegister = new UserRegister(stubWeakPasswordChecker, fakeRepository);
    }

    @Test
    void 이미_같은_ID가_존재하면_가입_실패() {
        // 이미 아이디가 존재하는 상황 생성 (repository.save())
        fakeRepository.save(new User("id", "pw1", "email@email.com"));

        assertThrows(DuplicateIdException.class, () -> {
            userRegister.register("id", "pw1", "email");
        });
    }
}
```

`UserRepository` 인터페이스를 구현하는 `MemoryUserRepository` 클래스를 만들고 컴파일 에러를 없앤다.

`User` 클래스도 만들고 `UserRepository` 인터페이스에 `save` 메서드를 추가하고 `MemoryUserRepository` 에 `save()` 메서드를 구현한다. 

```java
public interface UserRepository {
    void save(User user);
}
```

```java
public class MemoryUserRepository implements UserRepository {
    private Map<String, User> users = new HashMap<>();

    @Override
    public void save(User user) {
        users.put(user.getId(), user);
    }
}
```

이제는 테스트를 통과시킬 차례다.

`UserRegister` 클래스의 `register` 메서드에서 `DupIdException` 을 던지게 해서 테스트를 통과시킨다.

```java
public class UserRegister {
    private WeakPasswordChecker passwordChecker;
    private UserRepository userRepository;
    
    ...
    
    public void register(String id, String pw, String email) {
        if (passwordChecker.checkPasswordWeak(pw)) {
            throw new WeakPasswordException();
        }
        throw new DupIdException();
    }
}
```

테스트를 통과시켰으니 이제 구현을 일반화한다.

```java
public class UserRegister {
    private WeakPasswordChecker passwordChecker;
    private UserRepository userRepository;
    
    ...
    
    public void register(String id, String pw, String email) {
        if (passwordChecker.checkPasswordWeak(pw)) {
            throw new WeakPasswordException();
        }
        
        User user = userRepository.findById(id);
        if (user != null) {
            throw new DupIdException();
        }
    }
}
```

그런 뒤 `findById` 메서드를 구현해준다. (물론 인터페이스에도 추가해준다.)

```java
public class MemoryUserRepository implements UserRepository {
    private Map<String, User> users = new HashMap<>();

    @Override
    public void save(User user) {
        users.put(user.getId(), user);
    }

    @Override
    public User findById(String id) {
        return users.get(id);
    }
}
```

테스트가 통과한다.

중복 아이디가 존재하는 경우에 대한 테스트를 작성하고 구현했으니 이제 정상적으로 회원가입이 성공하는 경우에 대한 테스트도 추가한다.

```java
@Test
void 회원가입_성공() {
    userRegister.register("id", "pw", "email");

    User savedUser = fakeRepository.findById("id"); // 가입 결과 확인
    assertEquals("id", savedUser.getId());
    assertEquals("email", savedUser.getEmail());
}
```

`userRegister.register("id", "pw", "email");` 에서 새로운 회원이 정상적으로 등록되었는지 확인하는 코드를 추가했다. (fakeRepository 에)

하지만 `UserRegister.register()` 에 회원을 `users` 에 추가하는 코드가 아직 없어서 **NPE** 가 발생한다.

```java
public class UserRegister {
    private WeakPasswordChecker passwordChecker;
    private UserRepository userRepository;
    
    ...
    
    public void register(String id, String pw, String email) {
        if (passwordChecker.checkPasswordWeak(pw)) {
            throw new WeakPasswordException();
        }
        
        User user = userRepository.findById(id);
        if (user != null) {
            throw new DupIdException();
        }
        
        userRepository.save(new User("id", "pw", "email")); // 추가된 부분
    }
}
```

이렇게 해서 테스트를 통과시킨 뒤 구현을 일반화한다.

```java
public class UserRegister {
    private WeakPasswordChecker passwordChecker;
    private UserRepository userRepository;
    
    ...
    
    public void register(String id, String pw, String email) {
        if (passwordChecker.checkPasswordWeak(pw)) {
            throw new WeakPasswordException();
        }
        
        User user = userRepository.findById(id);
        if (user != null) {
            throw new DupIdException();
        }
        
        userRepository.save(new User(id, pw, email)); // 추가된 부분
    }
}
```

이렇게 하면 회원가입 성공 케이스에 대한 테스트 및 구현도 완성된다.

이런식으로 대역을 이용할때도 상수를 이용해서 테스트를 통과시킨 뒤 구현을 일반화한다.

만약 구현을 일반화할 방법이 생각나지 않는다면 예를 추가하면서 점진적으로 구현을 완성하면 된다.